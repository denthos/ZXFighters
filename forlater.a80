	This is for stuff that has code that may be useful later 



	cp 0					; Check if sprite 1 or 2 move
	jp nz, move_sprite_right_2		; If 1 then absolute jump to sprite 2 movement right code
	ld a,(sprite_one_x_location)		; Else load sprite 1 x position into a register
	cp 26					; Check if the sprite is already as far right as possible 
	jp z,_move_sprite_right_done_edge	; If so then skip to the end and return 


	for smoother movement 
	ld a, (sprite_one_x_bit_offset)		; Load the bit offsett to check to see where we are in the character cell 
	cp 7					; Check if the bit offset is = 7
	jp nz,move_right_bit_offset_normal		; If equal to 7 then increment sprite_one_x_location 
	xor a 					; Clear the a register 
	ld (sprite_one_x_bit_offset), a 	; Save 0 as the bit offset 
	ld a,(sprite_one_x_location)		; Else load sprite 1 x position into a register
	inc a					; Else increment a to move to the right of the screen 
	ld (sprite_one_x_location),a		; Save the updated x position in memory
	jp resume_move_sprite_right		; Absolute jump to skip normal case 
move_right_bit_offset_normal:
	inc a					; Increment the bit offset by normal (REPEATED CODE HERE)
	ld (sprite_one_x_bit_offset), a 	; Save the new bit offset into memory 
resume_move_sprite_right:
	

	inc a 
	ld b,a					; Load the updated x position into b register for calculate_color_cell_pixel_address
	ld a,(sprite_one_y_location)		; Load the sprite 1 y location into the a register to be loaded into the c register
	ld c,a					; Load the y position into the c register for calculate_color_cell_pixel_address
	;Check for overlapping 
	call check_sprite_overlap
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_right 		; a = 1 means overlapping now

	; We are good to go, no collisions
	; Code for keeping track of the pixel location 
	; Increment the x and save into memory

	; For smoother movement  
; 	ld a, (sprite_one_x_pixel_location)
; 	inc a 
; 	ld (sprite_one_x_pixel_location), a
; 	ld b, a 
; 	ld a, (sprite_one_y_pixel_location)
; 	ld c, a 
; 	call _finish_move_sprite_right		; Absoulte jump to actually draw the sprite in the new position


	ld a, 1
	ret  




; Drawing utils move right sprite

; 	ld a,(sprite_one_x_location)		; Else load sprite 1 x position into a register
; 	inc a					; Else increment a to move to the right of the screen
; 	ld (sprite_one_x_location),a		; Save the updated x position in memory
	; Check if the new character_cell in the other thing 
; 	call check_sprite_overlap
; 	cp 1					; Will set the Z flag if A == 1
; 	jp nz, resume_move_sprite_right;	; Absolute jump to skip normal case 	; a = 1 means overlapping now
; 	call _revert_move_right 

; 	jp _move_sprite_right_done_edge	


; 	cp 1
; 	jp z, _move_sprite_right_done_edge
; 	cp 3
; 	jp z, _move_sprite_right_done_edge
; 	cp 5
; 	jp z, _move_sprite_right_done_edge







; Draw util methods 

; ------------------------------------------------------------------------------
; Subroutine for drawing a sprite onto the screen 1 pixel below it's current
; location 
;
; Inputs: 
; 	IX - the input sprite to be input to the draw_sprite routine 
; 	A  - the sprite number ( 0 = sprite #1, 1 = sprite #2)
; Outputs:
;
; ------------------------------------------------------------------------------
move_sprite_down:
	cp 0					; Check if the first or second sprite
	jp nz, _move_sprite_down_2		; Load first sprite x location
; 	out (254), a		
	ld a, (sprite_one_y_location)		; Load the old y value of sprite 1 into a
	cp 18 					; Check if the sprite is at the last spot of the screen 
	jp nc, _move_sprite_down_done_edge
	inc a					; Increment a to move down 
; 	inc a					; Increment a again for some reason idk
	ld (sprite_one_y_location), a		; Save the new y location into memory
	ld c,a					; Load new y location into c for calculate_color_cell_pixel_address
	ld a, (sprite_one_x_location)		; Load sprite 1 x location into a in order to load into c
	ld b,a					; Load sprite 1 x location into b for calculate_color_cell_pixel_address
	call check_sprite_overlap		; Check to make sure no sprite overlap 
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_down  		; a = 1 means overlapping now
; 	call _finish_move_sprite_down		; Absolute jump to actually draw sprite to the new location 
	ld a, 1
	ret

_erase_old_sprite_down:
	ld a, (sprite_one_x_location)		; Ensure that a has the x value of sprite 1
	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
	ld a, (sprite_one_y_location)		; Load the new y location into the a register to sub 6 from 
; 	cp 6					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp c, _move_sprite_down_done		; If it is then just don't do anything 
	sub a, 1	
	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_vertical		; Actually clear the last column of color cells occupied 
	jp _move_sprite_down_done		; Finish and return 

_move_sprite_down_2:
	
	ld a, (sprite_two_y_location)		; Load the old y value of sprite 2 into a
	cp 18 					; Check if the sprite is at the second to last spot of the screen 
	jp nc, _move_sprite_down_done_edge
	inc a					; Increment a to move down 
; 	inc a					; Increment a again for some reason idk seems to work 
	ld (sprite_two_y_location), a		; Save the new y location into memory
	ld c,a					; Load sprite 2 x location into a in order to load into c
	ld a, (sprite_two_x_location)		; Load sprite 2 x location into b for calculate_color_cell_pixel_address
	ld b,a					; Absolute jump to actually draw sprite to the new location 
	call check_sprite_overlap		; Check to make sure no sprite overlap 
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_down_2  		; a = 1 means overlapping now
; 	call _finish_move_sprite_down
	ld a, 1
	ret 

; could improve by storing this information in registers that wouldn't be used?
_erase_old_sprite_down_2:
	ld a, (sprite_two_x_location)		; Ensure that a has the x value of sprite 1
	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
	ld a, (sprite_two_y_location)		; Load the new y location into the a register to sub 6 from 
; 	cp 6					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp c, _move_sprite_down_done		; If it is then just don't do anything 
	sub a, 1	
	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_vertical		; Actually clear the last column of color cells occupied  
	jp _move_sprite_down_done		; Finish and return 

_finish_move_sprite_down: 
	call calculate_color_cell_pixel_address ; This will load hl with the correct pixel address for draw sprite 
	ld c,0					; 0 for no overwrite
	ld d,6					; 6 for the width 
	call draw_sprite			; Actually draw the sprite to the new location 
	ret

_erase_old_sprite_down_finish: 
	call calculate_color_cell_pixel_address ; This will put the pixel address to draw to in the HL register
	ld c, 0
	ld d, 6
	ld ix, black_sprite
	call draw_sprite
	ret

_revert_move_down:
	ld a, (sprite_one_y_location)		; Load the new faulty x position into the register a 
	dec a					; Revert the change by decrementing the x position 
; 	dec a					; Revert the change by decrementing the x position 
	ld (sprite_one_y_location), a		; Save the position in memory
	ld a, 0 
	jp _move_sprite_down_done		; Finish 

_revert_move_down_2:
	ld a, (sprite_two_y_location)		; Load the new faulty x position into the regsiter a 
	dec a                                   ; Revert the change by decrementing the x position 
; 	dec a					; Revert the change by decrementing the x position 
	ld (sprite_two_y_location), a		; Save the position to memory
	ld a, 0 
	jp _move_sprite_down_done		; Finish 

_move_sprite_down_done_edge:
	ld a, 0 				; Output a is 0 to denote no drawing 
	ret

_move_sprite_down_done:
	ret

; ------------------------------------------------------------------------------
; Subroutine for drawing a sprite onto the screen 1 pixel above it's current 
; location
;
; Inputs: 
; 	IX - the input sprite tp be input to the draw_sprite routine 
; 	A  - the sprite number ( 0 = sprite #1, 1 = sprite #2)
; Outputs:
;
; ------------------------------------------------------------------------------
move_sprite_up:	
	cp 0					; Check if the sprite 1 or 2 moved
	jp nz, _move_sprite_up_2		; If so then move to the sprite 2 code
	ld a, (sprite_one_y_location)		; Load the old y location of sprite 1 into the a register
	cp 0					; Check if the sprite is at the top of screen 
	jp z,_move_sprite_up_done		; If so then skip to the end and return 
	dec a					; Else decrement a in order to move up 
	ld (sprite_one_y_location),a		; Save the new y position of sprite 1 in memory
	ld c,a					; Load the updated y position of sprite 1 into the c register for calculate_color_cell_pixel_address
	ld a,(sprite_one_x_location)		; Load the x position in a in order to load into b
	ld b,a					; Load the a register into b
	call check_sprite_overlap		; Check to make sure no sprite overlap 
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_up 	 		; a = 1 means overlapping now
; 	call _finish_move_sprite_up		; Actually draw the sprite in the new location 
	ld a, 1
	ret 

_erase_old_sprite_up:
	ld a, (sprite_one_x_location)		; Ensure that a has the x value of sprite 1
	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
	ld a, (sprite_one_y_location)		; Load the new y location into the a register to sub 6 from 
; 	cp 12					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp nc, _move_sprite_up_done		; If it is then just don't do anything 
	add a, 6	
	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_vertical	 	; Absolute jump to actually draw over old spot  
	jp _move_sprite_up_done			; Finish and return 

_move_sprite_up_2:
	ld a, (sprite_two_y_location)		; Load the old y postiion of sprite 2 into the a regsiter
	cp 0					; Check if at the top of the screen 
	jp z,_move_sprite_up_done		; If so then skip to the end and return 
	dec a					; Decrement a inorder to move up the screen 
	ld (sprite_two_y_location),a		; Save the new y position of sprite 2 into memory 
	ld c,a					; Load a into c in order to load the y position into b for calculate_color_cell_pixel_address
	ld a,(sprite_two_x_location)		; Load the x position of sprite 2 into a in order to move into b for calculate_color_cell_pixel_address
	ld b,a					; Load the x position into b
	call check_sprite_overlap		; Check to make sure no sprite overlap 
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_up_2 		; a = 1 means overlapping now
; 	call _finish_move_sprite_up		; Check overlap 
	ld a, 1
	ret 

_erase_old_sprite_up_2:
	ld a, (sprite_two_x_location)		; Ensure that a has the x value of sprite 1
	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
	ld a, (sprite_two_y_location)		; Load the new y location into the a register to sub 6 from 
; 	cp 12					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp nc, _move_sprite_up_done		; If it is then just don't do anything 
	add a, 6	
	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_vertical	 	; Call to actually draw over old spot  
	jp _move_sprite_up_done			; Finish and return

_finish_move_sprite_up:
	call calculate_color_cell_pixel_address	; Will load the address of the first pixel to draw to into HL 
	ld c,0					; Overwrite to false
	ld d,6					; Width of sprite to 6
	call draw_sprite			; ix has sprite data
	ret

_erase_old_sprite_up_finish: 
	call calculate_color_cell_pixel_address ; This will put the pixel address to draw to in the HL register
	ld c, 0
	ld d, 6
	ld ix, black_sprite
	call draw_sprite
	ret

_revert_move_up:
	ld a, (sprite_one_y_location)		; Load the new faulty x position into the register a 
	inc a					; Revert the change by decrementing the x position 
	ld (sprite_one_y_location), a		; Save the position in memory
	ld a, 0 
	jp _move_sprite_up_done		; Finish 

_revert_move_up_2:
	ld a, (sprite_two_y_location)		; Load the new faulty x position into the regsiter a 
	inc a                                   ; Revert the change by decrementing the x position 
	ld (sprite_two_y_location), a		; Save the position to memory
	ld a, 0
	jp _move_sprite_up_done		; Finish 


_move_sprite_up_done_edge:
	ld a,0 
	ret

_move_sprite_up_done:
	ret					; Finish 


; ; ------------------------------------------------------------------------------
; ; Subroutine for drawing a sprite onto the screen 1 pixel to the right and one 
; ; pixel above.
; ;
; ; Inputs: 
; ; 	IX - the input sprite to be input to draw_sprite routine 
; ; 	A  - the sprite number ( 0 = sprite #1, 1 = sprite #2)
; ; Outputs:
; ; 	N/A 
; ; ------------------------------------------------------------------------------
; move_sprite_up_right_diagonal:	
; 	cp 0					; Check if the sprite 1 or 2 moved
; 	jp nz, move_sprite_up_right_diagonal_2	; If so then move to the sprite 2 code
; 	ld a, (sprite_one_y_location)		; Load the old y location of sprite 1 into the a register
; 	cp 0					; Check if the sprite is at the top of screen 
; 	jp z,_move_sprite_up_done		; If so then skip to the end and return 
; 	dec a					; Else decrement a in order to move up 
; 	ld (sprite_one_y_location),a		; Save the new y position of sprite 1 in memory
; 	ld c,a					; Load the updated y position of sprite 1 into the c register for calculate_color_cell_pixel_address
; 	ld a,(sprite_one_x_location)		; Load the x position in a in order to load into b
; 	ld b,a					; Load the a register into b
; 	call check_sprite_overlap		; Check to make sure no sprite overlap 
; 	cp 1					; Will set the Z flag if A == 1
; 	jp z, _revert_move_up 	 		; a = 1 means overlapping now
; 	call _finish_move_sprite_up		; Actually draw the sprite in the new location 


; _erase_old_sprite_up_right_diagonal:
; 	ld a, (sprite_one_x_location)		; Ensure that a has the x value of sprite 1
; 	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
; 	ld a, (sprite_one_y_location)		; Load the new y location into the a register to sub 6 from 
; ; 	cp 12					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; ; 	jp nc, _move_sprite_up_done		; If it is then just don't do anything 
; 	add a, 6	
; 	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
; 	call clear_old_sprite_vertical	 	; Absolute jump to actually draw over old spot  
; 	jp _move_sprite_up_done			; Finish and return 

; move_sprite_up_right_diagonal_2:
; 	ld a, (sprite_two_y_location)		; Load the old y postiion of sprite 2 into the a regsiter
; 	cp 0					; Check if at the top of the screen 
; 	jp z,_move_sprite_up_done		; If so then skip to the end and return 
; 	dec a					; Decrement a inorder to move up the screen 
; 	ld (sprite_two_y_location),a		; Save the new y position of sprite 2 into memory 
; 	ld c,a					; Load a into c in order to load the y position into b for calculate_color_cell_pixel_address
; 	ld a,(sprite_two_x_location)		; Load the x position of sprite 2 into a in order to move into b for calculate_color_cell_pixel_address
; 	ld b,a					; Load the x position into b
; 	call check_sprite_overlap		; Check to make sure no sprite overlap 
; 	cp 1					; Will set the Z flag if A == 1
; 	jp z, _revert_move_up_2 		; a = 1 means overlapping now
; 	call _finish_move_sprite_up_right_diagonal		; Check overlap 

; _erase_old_sprite_up_right_diagonal_2:
; 	ld a, (sprite_two_x_location)		; Ensure that a has the x value of sprite 1
; 	ld b, a 				; Reload the old x value into b for calculate_color_cell_pixel_address
; 	ld a, (sprite_two_y_location)		; Load the new y location into the a register to sub 6 from 
; ; 	cp 12					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; ; 	jp nc, _move_sprite_up_done		; If it is then just don't do anything 
; 	add a, 6	
; 	ld c, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
; 	call clear_old_sprite_vertical	 	; Call to actually draw over old spot  
; 	jp _move_sprite_up_done			; Finish and return

; _finish_move_sprite_up_right_diagonal:
; 	call calculate_color_cell_pixel_address	; Will load the address of the first pixel to draw to into HL 
; 	ld c,0					; Overwrite to false
; 	ld d,6					; Width of sprite to 6
; 	call draw_sprite			; ix has sprite data
; 	ret

; _erase_old_sprite_up_right_diagonal_finish: 
; 	call calculate_color_cell_pixel_address ; This will put the pixel address to draw to in the HL register
; 	ld c, 0
; 	ld d, 6
; 	ld ix, black_sprite
; 	call draw_sprite
; 	ret

; _revert_move_up_right_diagonal:
; 	ld a, (sprite_one_y_location)		; Load the new faulty x position into the register a 
; 	inc a					; Revert the change by decrementing the x position 
; 	ld (sprite_one_y_location), a		; Save the position in memory
; 	jp _move_sprite_up_done		; Finish 

; _revert_move_up_up_right_diagonal_2:
; 	ld a, (sprite_two_y_location)		; Load the new faulty x position into the regsiter a 
; 	inc a                                   ; Revert the change by decrementing the x position 
; 	ld (sprite_two_y_location), a		; Save the position to memory
; 	jp _move_sprite_up_done		; Finish 

; _move_sprite_up_done:
; 	ret	


; Check overlap stuff


	; This is for y axis checking, not needed for our game anymore 
; 	ld a, (sprite_one_y_location)
; 	call absA
; 	ld d, a

; 	ld a, (sprite_two_y_location)
; 	call absA

; 	sub d 
; 	call absA
; 	cp 6
; 	jp nc, return_sprite_overlap_false 	; If it is equal to 6 or greater then return false



; Subtract sprite two x from sprite one, guarenteed to be positive 
	;call absA ; Only needed for when characters can jump over on another 

	; a now has the value of x2 - x1 

	; Compare with the pre_calculate_offset_middle
; 	ld d, a ; save the difference in d 




; ------------------------------------------------------------------------------
; Routine to make the sprite jump on screen
; 
; Inputs: 
;	A - the number of the sprite (0 -> sprite 1) (1 -> sprite 2)
; Outputs:
;	A - 1 for overlapping 0 for not overlapping
; ------------------------------------------------------------------------------
move_sprite_jump:
	ld (jump_sprite_number), a	; Save the sprite number to memory
	xor a				; Clear the a register 
	add a,3				; Set it to 3 
	ld b, a				; Load the counter number into b
	push ix				; Push the pointer to the sprite data 

_save_jump_sprite_counter_up:
	ld a, b 			; Load decremented b to a
	ld (jump_sprite_counter), a 	; Save counter to memory
	ld a, (jump_sprite_number)	; Set up a for call to M_S_U
	pop ix 				; Pop to get the correct pointer to sprite data 
	push ix 			; Push to save a copy of the pointer 
_move_jump_sprite_up: 		
	call move_sprite_up		; Move the sprite up 
	call _finish_move_sprite_up
	ld a, (jump_sprite_number)
	cp 1 
	jp z, _move_jump_sprite_up_erase_2
	call _erase_old_sprite_up
	jp _resume_move_jump_sprite_up
_move_jump_sprite_up_erase_2:
	call _erase_old_sprite_up_2

_resume_move_jump_sprite_up:
	ld a, (jump_sprite_counter)	; Load counter back into a
	ld b, a 			; Move a to b 
	call halt_8 
	djnz _save_jump_sprite_counter_up; Decrement b 
	ld a, b 			; end of the loop 
	add a, 3 
	ld b, a

_save_jump_sprite_counter_down:
	ld a, b
	ld (jump_sprite_counter), a 	; Save counter to memory
	ld a, (jump_sprite_number)	; Set up a for call to M_S_U
	pop ix 				; Pop to get the correct pointer to sprite data 
	push ix 			; Push to save a copy of the pointer 
_move_jump_sprite_down:	
	call move_sprite_down		; Move the sprite up 
	call _finish_move_sprite_down
	ld a, (jump_sprite_number)		; Restore the a to check which sprite needs to be erased
	cp 1
	jp z, _move_jump_sprite_down_erase_2
	call _erase_old_sprite_down
	jp _resume_move_jump_sprite_down
_move_jump_sprite_down_erase_2:
	call _erase_old_sprite_down_2

_resume_move_jump_sprite_down:
	ld a, (jump_sprite_counter)		; Load counter back into a
	ld b, a 				; Move a to b 
	call halt_8 			
	djnz _save_jump_sprite_counter_down	; Decrement b 

_move_sprite_jump_done:

	ret
; ------------------------------------------------------------------------------
; Subroutine for getting the absolute value if the accumulator register
; ------------------------------------------------------------------------------
absA:
	cp $80                         ; comparing the unsigned A to 128
 	jr c,A_Is_Positive             ; if it is less, then jump to the label given
	neg                            ; multiplying A by -1
A_Is_Positive:
	ret
;      or a
;      ret p
;      neg         ;or you can use      cpl \ inc a
;      ret




; For checking if c should be blend or not 
; 	call clear_sprite
; 	call _move_sprite_right_done_edge
; 	ret 
; 	ret 	
; 	; Check if c should blend or overwrite 
; 	ld a, (sprite_one_x_location)
; 	ld b, a 
; 	ld a, (sprite_two_x_location)
; 	sub b ; subs b from a and stores in a (a = a - b)
; 	cp 6 
; 	jp nc, _finish_move_sprite_right_no_blend ; Greater than or equal to 6 then no blend 
; 	ld c, 1
; 	jp _continue_finish_move_sprite_right_from_blend
; _finish_move_sprite_right_no_blend:
; 	ld c, 0					; Set to not overwrite
; _continue_finish_move_sprite_right_from_blend:


; 	call calculate_color_cell_pixel_address
; 	call clear_sprite
; 	ld a, (sprite_one_x_location)		; Save the updated x position in memory
; 	ld b,a
; 	ld a,(sprite_one_y_location)		; Load the sprite 1 y location into the a register to be loaded into the c register
; 	ld c,a					; Load the y position into the c register for calculate_color_cell_pixel_address



;move sprite right 2

; 	call check_sprite_overlap
; 	cp 1					; Will set the Z flag if A == 1, means overlapping 
; 	jp z, _revert_move_right_2 		; a = 1 means overlapping now







; Clearing stuff 


; _erase_old_sprite_right_2:
; 	ld a, (sprite_two_y_location)		; Ensure that a has the y value of sprite 1
; 	ld c, a 				; Reload the old y value into b for calculate_color_cell_pixel_address
; 	ld a, (sprite_two_x_location)		; Load the new x location into the a register to sub 6 from 
; 	sub a, 1	
; 	ld b, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
; 	call clear_old_sprite_horizontal
; 	jp _move_sprite_right_done		; Finish and return 


_erase_old_sprite_right:
	ld a, (sprite_one_y_location)		; Ensure that a has the y value of sprite 1
	ld c, a 				; Reload the old y value into c for calculate_color_cell_pixel_address
	ld a, (sprite_one_x_location)		; Load the new x location into the a register to sub 6 from 
	sub a, 1				; Just draw the char cell to the left	
	ld b, a 				; Load the original(old) x into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_horizontal	; Actually clear the last column of color cells occupied
	jp _move_sprite_right_done		; Finish and return 




; ------------------------------------------------------------------------------
; Routine for drawing 1 character cell in 6 consecutive rows in the same column 
;
; Note: There is probably some way to do this like with EXX but it all seems 
; really hard lol
; Inputs: 
; 
; 	b = x
;	c = y
; Outputs: 
; ------------------------------------------------------------------------------
clear_old_sprite_horizontal: 
	; save the x and y before drawing the thing which will modify them 
	ld a, 6 
	ld (clear_loop_counter), a
_clear_old_sprite_loop_horizontal: 
	ld a, b
	ld (current_sprite_x_location), a
	ld a, c
	ld (current_sprite_y_location), a
	call draw_black_character_cell		; This will modify a
	ld a, (clear_loop_counter)
	dec a
	cp 0
	jp z, _finish_clear_old_sprite_horizontal
	ld (clear_loop_counter), a
	ld a, (current_sprite_x_location)
	ld b, a
	ld a, (current_sprite_y_location)
	inc a
	ld c, a 
	ld (current_sprite_y_location), a
	jp _clear_old_sprite_loop_horizontal
	;update the values 
_finish_clear_old_sprite_horizontal:
	ret


; ------------------------------------------------------------------------------
; Routine for drawing 1 character cell in 6 columns in the same row
; 
; Note: There is probably some way to do this like with EXX but it all seems 
; really hard lol
; Inputs: 
; 
; 	b = x
;	c = y
; Outputs: 
; ------------------------------------------------------------------------------
clear_old_sprite_vertical: 
	; save the x and y before drawing the thing which will modify them 
	ld a, 6 
	ld (clear_loop_counter), a
_clear_old_sprite_loop_vertical: 
	ld a, b
	ld (current_sprite_x_location), a
	ld a, c
	ld (current_sprite_y_location), a
	call draw_black_character_cell		; This will modify a
	ld a, (clear_loop_counter)
	dec a
	cp 0
	jp z, _finish_clear_old_sprite_vertical
	ld (clear_loop_counter), a
	ld a, (current_sprite_x_location)
	inc a					; This is the only difference between the two methods...
	ld b, a
	ld a, (current_sprite_y_location)
	ld c, a 
	ld (current_sprite_y_location), a
	jp _clear_old_sprite_loop_vertical 
	;update the values 
_finish_clear_old_sprite_vertical:
	ret



_erase_old_sprite_left:
	ld a, (sprite_one_y_location)		; Ensure that a has the y value of sprite 1
	ld c, a 				; Reload the old y value into b for calculate_color_cell_pixel_address
	ld a, (sprite_one_x_location)		; Load the new x location into the a register to sub 6 from 
; 	cp 24					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp nc, _move_sprite_left_done		; If it is then just don't do anything 
	add a, 6	
	ld b, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_horizontal	; Actually clear the last column of color cells occupied  
	jp _move_sprite_left_done		; Finish and return 

_erase_old_sprite_left_2:
	ld a, (sprite_two_y_location)		; Ensure that a has the y value of sprite 1
	ld c, a 				; Reload the old y value into b for calculate_color_cell_pixel_address
	ld a, (sprite_two_x_location)		; Load the new x location into the a register to sub 6 from 
; 	cp 24					; Check if the sprite is starting within the top 6 pixel blocks of the screen 
; 	jp nc, _move_sprite_left_done		; If it is then just don't do anything 
	add a, 6	
	ld b, a 				; Load the original y into the c register for calculate_color_cell_pixel_address
	call clear_old_sprite_horizontal	; Actually clear the last column of color cells occupied 
	jp _move_sprite_left_done		; Finish and return 


; _finish_move_sprite_left:
; 	call calculate_color_cell_pixel_address ; sprite data shold already be in ix, this will set HL with address
; 	ld c,0					; 0 for no overwrite
; 	ld d,6					; 6 for the width of the sprite 
; 	call draw_sprite			; Draw sprite to updated location of screen
; 	ret


; Tuning movement speed

; 	cp 1
; 	jp z, _move_sprite_left_done_edge
; 	cp 3
; 	jp z, _move_sprite_left_done_edge
; 	cp 5
; 	jp z, _move_sprite_left_done_edge



;Commented out code for a basic running jump 
; play_loop:

;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_up
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_up

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right

;       call halt_8

;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_up
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_up

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right

;       call halt_8

;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_up
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_up

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right

;       call halt_8


; ; - --- - -- - - - - - - - - - -  -- - - - -- - - -

;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_down
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_down

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right


;       call halt_8


;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_down
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_down

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right


;       call halt_8


;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_down
;       cp 0                                ; Check if movement is allowed 
;       jp z, end 
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_down

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, end 
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_jump




;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_down
;       cp 0                                ; Check if movement is allowed 
;       jp z, play_loop
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_down

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, play_loop
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right

;       ld ix, shoe_sprite_data 
;       call halt_2 
;       ld a, 0 
;       call move_sprite_down
;       cp 0                                ; Check if movement is allowed 
;       jp z, play_loop
; ;       call _finish_move_sprite_up
;       call _erase_old_sprite_down

;       ld a, 0 
;       ld ix, shoe_sprite_data 
;       call move_sprite_right
;       cp 0 
;       jp z, play_loop
;       call _finish_move_sprite_right
;       call _erase_old_sprite_right



; In revert thing 
; 	ld b, a
; 	ld a, (sprite_one_y_location)
; 	ld c, a
; 	ld ix, shoe_sprite_data
; 	ld a, 0 
; 	call _finish_move_sprite_right	


	ld b, a 
	ld a, (sprite_two_y_location)
	ld c, a
	call _finish_move_sprite_right	