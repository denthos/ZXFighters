	This is for stuff that has code that may be useful later 



	cp 0					; Check if sprite 1 or 2 move
	jp nz, move_sprite_right_2		; If 1 then absolute jump to sprite 2 movement right code
	ld a,(sprite_one_x_location)		; Else load sprite 1 x position into a register
	cp 26					; Check if the sprite is already as far right as possible 
	jp z,_move_sprite_right_done_edge	; If so then skip to the end and return 


	;for smoother movement 
; 	ld a, (sprite_one_x_bit_offset)		; Load the bit offsett to check to see where we are in the character cell 
; 	cp 7					; Check if the bit offset is = 7
; 	jp nz,move_right_bit_offset_normal		; If equal to 7 then increment sprite_one_x_location 
; 	xor a 					; Clear the a register 
; 	ld (sprite_one_x_bit_offset), a 	; Save 0 as the bit offset 
; 	ld a,(sprite_one_x_location)		; Else load sprite 1 x position into a register
; 	inc a					; Else increment a to move to the right of the screen 
; 	ld (sprite_one_x_location),a		; Save the updated x position in memory
; 	jp resume_move_sprite_right		; Absolute jump to skip normal case 
; move_right_bit_offset_normal:
; 	inc a					; Increment the bit offset by normal (REPEATED CODE HERE)
; 	ld (sprite_one_x_bit_offset), a 	; Save the new bit offset into memory 
; resume_move_sprite_right:
	

	inc a 
	ld b,a					; Load the updated x position into b register for calculate_color_cell_pixel_address
	ld a,(sprite_one_y_location)		; Load the sprite 1 y location into the a register to be loaded into the c register
	ld c,a					; Load the y position into the c register for calculate_color_cell_pixel_address
	;Check for overlapping 
	call check_sprite_overlap
	cp 1					; Will set the Z flag if A == 1
	jp z, _revert_move_right 		; a = 1 means overlapping now

	; We are good to go, no collisions
	; Code for keeping track of the pixel location 
	; Increment the x and save into memory

	; For smoother movement  
; 	ld a, (sprite_one_x_pixel_location)
; 	inc a 
; 	ld (sprite_one_x_pixel_location), a
; 	ld b, a 
; 	ld a, (sprite_one_y_pixel_location)
; 	ld c, a 
; 	call _finish_move_sprite_right		; Absoulte jump to actually draw the sprite in the new position


	ld a, 1
	ret  